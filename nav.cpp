//////////////////////////////////////////////////////////////////////////////
// nav.cpp
// プレーヤーの移動を管理するモジュール。ダンジョンの中でのプレーヤーの移動を
// 処理します。このモジュールにはダンジョンの構成情報も含まれています
// Richard S. Wright Jr.
//////////////////////////////////////////////////////////////////////////////

// Win32の必要のない機能は省きます
#define WIN32_LEAN_AND_MEAN

#include <windows.h>		// Windowsの標準ヘッダー
#include <math.h>			// 数学関数 (sin()とcos())
#include <d3drmwin.h>		// Direct3D保持モードAPI
#include "sound.h"			// サウンド機能

#include "nav.h"

extern int nScore;

int g_iMapRow = 17;			// ダンジョンのグリッド上の位置
int g_iMapCol = 10;

float g_fCellRow = 3.0f;	// セルの位置は0.0から6.0の範囲で、
float g_fCellCol = 3.0f;	// (3,3) が中心

int g_iRotIndex = 0;		// プレーヤーの向きのインデックス
							// このグローバル変数は、あらかじめ計算しておいた
							// sin()とcos()の配列のインデックスとして使います

float fAngleLookUp[36];		// プレーヤーの向き (角度) の処理で、浮動小数の計算を避けるために
							// 角度をこの配列に並べておきます。

float fSineLookUp[36];		// fAngleLookUpの計算のために用意しておきます
							// sin()の値の配列

float fCosineLookUp[36];	// fAngleLookUpの計算のために用意しておきます
							// cos()の値の配列


// ダンジョンの配置はこの配列で決まります。プレーヤーは、0になっている位置には
// 移動できません。他の値はその位置の壁の組み合わせを示すコードになっています

/* 初期のコード */
int iDungeon[MAX_ROW][MAX_COL] = {
{ 3, 10,  5,  0,  0,  3, 10,  5,  0,  0,  0,  0,  0,  0,  3, 10,  5,  0,  0,  0,  0,  0 }, 
{ 8,  7,  9,  0,  0,  8,  7,  9,  0,  0,  3,  2,  2, 16, 23,  7,  9,  0,  0,  0,  0,  0 },
{ 4, 21,  6,  0,  0,  4, 21,  6,  0,  0,  1,  0,  0,  0,  4, 11,  6,  0,  0,  0,  0,  0 }, 
{ 0, 14,  0,  0,  3,  2, 17,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 }, 
{ 0,  1,  0,  0,  1,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 }, 
{ 0,  1,  0,  0,  1,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  3, 10,  5,  0,  0,  0,  0 }, 
{ 0,  4,  2,  2,  7,  2,  2, 10,  2,  2,  6,  0,  0,  0,  0,  8,  7,  9,  0,  0,  0,  0 }, 
{ 0,  0,  0,  0,  1,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  4, 21,  6,  0,  0,  0,  0 }, 
{ 0,  0,  0,  0, 15,  0,  0,  1,  0,  0,  3,  2,  2,  2,  2,  2, 18,  2,  5,  0,  0,  0 }, 
{ 0,  0,  0,  3, 22,  5,  0,  1,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0 }, 
{ 0,  0,  0,  8,  7,  9,  0,  1,  0,  0,  1,  0,  0,  0,  3, 10,  5,  0,  1,  3, 10,  5 }, 
{ 0,  0,  0,  4, 11,  6,  0,  1,  0,  0,  1,  0,  0,  0,  8,  7,  9,  0, 20, 23,  7,  9 }, 
{ 0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  1,  0,  0,  0,  4, 21,  6,  0,  1,  4, 11,  6 }, 
{ 0,  0,  0,  0,  0,  0,  0,  4,  2,  2,  7,  2,  2,  2,  2, 24,  2,  2,  6,  0,  0,  0 }, 
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  3, 22,  5,  0,  0,  0,  0,  0 }, 
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  8,  7,  9,  0,  0,  0,  0,  0 }, 
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  4, 11,  6,  0,  0,  0,  0,  0 }, 
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 25,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 }};


/* 改造マップ

int iDungeon[MAX_ROW][MAX_COL] = {
{ 0, 0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0 }, 
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  3,  2,  2, 0, 0,  0,  0,  0,  0,  0,  0,  0 },
{ 0, 0,  0,  0,  0,  0, 0,  0,  0,  1,  1,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0 }, 
{ 0, 0,  0,  0,  0,  0, 0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 }, 
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 }, 
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0 }, 
{ 0,  0,  0,  0,  0,  0,  0, 0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 }, 
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0 }, 
{ 0,  0,  0,  0, 0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0 }, 
{ 0,  0,  0,  0, 0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 }, 
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  22,  0, 0,  0,  0,  0,  0, 0,  0 }, 
{ 0,  1,  0,  0, 0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0, 0, 0,  0,  0 }, 
{ 0,  1,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0, 0,  0,  0,  0,  0, 0,  0 }, 
{ 0,  1,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0 }, 
{ 0,  1,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0 }, 
{ 0,  1,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 }, 
{ 0,  1,  0,  0,  0,  0,  0,  1,  1,  1,  1,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0 }, 
{ 0,  0,  0,  0,  0,  0,  0,  1,  1,  1, 25,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 }};

*/

///////////////////////////////////////////////////////////////////////////////
// 回転角とそれに対応するsin()、cos()の値をあらかじめ計算し配列に並べておきます
///////////////////////////////////////////////////////////////////////////////
void SetupNavigator(void){

	//	2 * PI
	float fStep = 6.28318530718f / 36.0f;	// 1回転の1/36
                         // 36を選択したのは、これが十分小さな角度で、
                         // かつ4の倍数だからです
                         // 4で割り切れない値を選択すると正確に
                         // 東西南北を向くことができません

	for(int i = 0; i < 36; i++){
		fAngleLookUp[i] = fStep*(float)i;
		fSineLookUp[i] = sin(fAngleLookUp[i]);
		fCosineLookUp[i] = cos(fAngleLookUp[i]);
	}
	
	g_iRotIndex = 0;

}

///////////////////////////////////////////////////////////////////////////////
// プレーヤーを左に回転させます (方向を示す配列のインデックスを減少させます)
///////////////////////////////////////////////////////////////////////////////
float TurnLeft(void){
	g_iRotIndex--;

	if(g_iRotIndex < 0)
		g_iRotIndex = 35;

	return fAngleLookUp[g_iRotIndex];
}

///////////////////////////////////////////////////////////////////////////////
// プレーヤーを右に回転させます (方向を示す配列のインデックスを増加させます)
///////////////////////////////////////////////////////////////////////////////
float TurnRight(void){
	g_iRotIndex++;

	if(g_iRotIndex > 35)
		g_iRotIndex = 0;

	return fAngleLookUp[g_iRotIndex];
}

///////////////////////////////////////////////////////////////////////////////
// プレーヤーを右に素早く回転させます (Shiftキーが押されているとき)
///////////////////////////////////////////////////////////////////////////////
float SwingLeft(void){
	TurnLeft();
	return TurnLeft();
}

///////////////////////////////////////////////////////////////////////////////
// プレーヤーを右に素早く回転させます (Shiftキーが押されているとき)
///////////////////////////////////////////////////////////////////////////////
float SwingRight(void){
	TurnRight();
	return TurnRight();
}

///////////////////////////////////////////////////////////////////////////////
// プレーヤーのx座標を返します (地図の配列のセルを示します)
//////////////////////////////////////////////////////////////////////////////
float fGetXPos(void){
	return ((float)g_iMapCol * 6.0f) + g_fCellCol;
}

///////////////////////////////////////////////////////////////////////////////
// プレーヤーのz座標を返します (地図の配列のセルを示します)
//////////////////////////////////////////////////////////////////////////////
float fGetZPos(void){
	return ((float)(17-g_iMapRow) * 6.0f) + g_fCellRow;
}

///////////////////////////////////////////////////////////////////////////////
// プレーヤーの向きを返します (テーブル参照)
//////////////////////////////////////////////////////////////////////////////
float fGetAngle(void){
	return fAngleLookUp[g_iRotIndex];
}

///////////////////////////////////////////////////////////////////////////////
// プレーヤーの現在の向きに応じて移動を処理します (前進)
///////////////////////////////////////////////////////////////////////////////
void StepForward(void){
	Move(2.0f * fSineLookUp[g_iRotIndex] , 2.0f * fCosineLookUp[g_iRotIndex]);
}

///////////////////////////////////////////////////////////////////////////////
// プレーヤーの現在の向きに応じて移動を処理します (後退)
///////////////////////////////////////////////////////////////////////////////
void StepBackward(void){
	Move(-(2.0f*fSineLookUp[g_iRotIndex]) , -(2.0f * fCosineLookUp[g_iRotIndex]));
}

///////////////////////////////////////////////////////////////////////////////
// 前に走ります (Shiftキーが押されているとき、前に2倍の速度で移動します)
///////////////////////////////////////////////////////////////////////////////
void RunForward(void){
	StepForward();
	StepForward();
}

///////////////////////////////////////////////////////////////////////////////
// 後ろに走ります (Shiftキーが押されているとき、後ろに2倍の速度で移動します)
///////////////////////////////////////////////////////////////////////////////
void RunBackward(void){
	StepBackward();
	StepBackward();
}

//////////////////////////////////////////////////////////////////////////////
// プレーヤーの移動を処理する汎用関数
// 前後の動きを処理します。行と列の変化分をパラメータとして与えます
void Move(float fCellColDelta, float fCellRowDelta){
	// 新しい位置を格納する一時的な変数
	// プレーヤーが壁を通り抜けようとしている場合は、移動させません
	float ftmpNewCellCol, ftmpNewCellRow;
	int ntmpNewMapCol, ntmpNewMapRow;

	// 現在の位置に加算します
	ftmpNewCellCol = g_fCellCol + fCellColDelta;
	ftmpNewCellRow = g_fCellRow + fCellRowDelta;

	// 以前のセル位置を取得します
	ntmpNewMapCol = g_iMapCol;
	ntmpNewMapRow = g_iMapRow;


	// 元のセル内に収まっているかをチェックします
	// 行方向のチェック（1）
	if(ftmpNewCellCol > 5.0f){
		ftmpNewCellCol = 1.0f;
		ntmpNewMapCol++;
	}

	// 行方向のチェック（2）
	if(ftmpNewCellCol < 1.0f){
		ftmpNewCellCol = 5.0f;
		ntmpNewMapCol--;
	}

	// 列方向のチェック（1）
	if(ftmpNewCellRow > 5.0f){
		ftmpNewCellRow = 1.0f;
		ntmpNewMapRow--;
	}

	// 列方向のチェック（2）
	if(ftmpNewCellRow < 1.0f){
		ftmpNewCellRow = 5.0f;
		ntmpNewMapRow++;
	}

	///////////////////////////////////////////////////////////////////
	// 新しい位置が計算されました。有効な移動であるかどうか確認します
	// 移動が無効な場合は、うめき声を再生し、位置を変更せずに終了します

	// 境界のチェック（行）
	if(ntmpNewMapRow > MAX_ROW || ntmpNewMapRow < 0){
		sndGrunt();
		return;
	}

	// 境界のチェック（列）
	if(ntmpNewMapCol > MAX_COL || ntmpNewMapCol < 0){
		sndGrunt();
		return;
	}

	// 壁を通り抜けてダンジョンの外に出ようとしていないか確認します
	if(iDungeon[ntmpNewMapRow][ntmpNewMapCol] == 0){
		sndGrunt();
		return;
	}

	///////////////////////////////////////////////////////////
	// 問題がない場合は、位置を更新します
	g_fCellCol = ftmpNewCellCol;
	g_fCellRow = ftmpNewCellRow;
	g_iMapCol = ntmpNewMapCol;
	g_iMapRow = ntmpNewMapRow;

	// 金貨があるか確認します
	if(bCheckForScore(g_iMapRow, g_iMapCol)){
		sndScore();
		nScore++;
	}

}